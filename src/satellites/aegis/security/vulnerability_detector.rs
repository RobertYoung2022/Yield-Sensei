use crate::types::{RiskAlert, AlertType, RiskLevel, PositionId};
use async_trait::async_trait;
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::RwLock;
use tracing::{info, warn, error, debug};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityReport {
    pub contract_address: String,
    pub risk_score: u8, // 0-100
    pub confidence_score: u8, // 0-100
    pub vulnerabilities: Vec<Vulnerability>,
    pub risk_factors: Vec<RiskFactor>,
    pub recommendations: Vec<SecurityRecommendation>,
    pub analysis_metadata: AnalysisMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub severity: VulnerabilitySeverity,
    pub category: VulnerabilityCategory,
    pub description: String,
    pub impact: String,
    pub confidence: u8, // 0-100
    pub cvss_score: Option<f32>,
    pub cwe_id: Option<String>,
    pub affected_functions: Vec<String>,
    pub proof_of_concept: Option<String>,
    pub remediation: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskFactor {
    pub factor_type: RiskFactorType,
    pub weight: f32, // 0.0-1.0
    pub score: u8, // 0-100
    pub description: String,
    pub evidence: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskFactorType {
    CodeComplexity,
    ExternalDependencies,
    PrivilegeEscalation,
    DataExposure,
    BusinessLogic,
    GasOptimization,
    Upgradeability,
    Governance,
    Oracle,
    Liquidation,
    Flashloan,
    CrossChain,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityRecommendation {
    pub priority: RecommendationPriority,
    pub category: String,
    pub title: String,
    pub description: String,
    pub implementation_effort: ImplementationEffort,
    pub impact_reduction: u8, // 0-100
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RecommendationPriority {
    Critical,
    High,
    Medium,
    Low,
    Informational,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ImplementationEffort {
    Low,
    Medium,
    High,
    Extreme,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisMetadata {
    pub analyzed_at: DateTime<Utc>,
    pub analysis_version: String,
    pub contract_size_bytes: Option<usize>,
    pub functions_analyzed: usize,
    pub analysis_duration_ms: u64,
    pub data_sources: Vec<String>,
    pub compiler_version: Option<String>,
    pub is_verified: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VulnerabilitySeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl VulnerabilitySeverity {
    pub fn score(&self) -> u8 {
        match self {
            VulnerabilitySeverity::Info => 10,
            VulnerabilitySeverity::Low => 25,
            VulnerabilitySeverity::Medium => 50,
            VulnerabilitySeverity::High => 75,
            VulnerabilitySeverity::Critical => 95,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VulnerabilityCategory {
    Reentrancy,
    IntegerOverflow,
    AccessControl,
    Oracle,
    Logic,
    Governance,
    Upgradeability,
    Denial,
    Information,
    Flashloan,
    MEV,
    Liquidation,
    CrossChain,
    GasGriefing,
    TimeLock,
    Signature,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractAnalysisRequest {
    pub contract_address: String,
    pub chain_id: u64,
    pub priority: AnalysisPriority,
    pub requested_by: Option<String>,
    pub position_ids: Vec<PositionId>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnalysisPriority {
    Low,
    Normal,
    High,
    Critical,
}

pub struct SmartContractVulnerabilityDetector {
    vulnerability_database: Arc<DashMap<String, VulnerabilityReport>>,
    known_exploits: Arc<DashMap<String, ExploitPattern>>,
    audit_databases: Vec<Box<dyn AuditDatabase>>,
    bytecode_analyzer: BytecodeAnalyzer,
    transaction_monitor: TransactionPatternMonitor,
    scoring_engine: VulnerabilityScoringEngine,
    config: Arc<RwLock<DetectorConfig>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitPattern {
    pub pattern_id: String,
    pub name: String,
    pub description: String,
    pub bytecode_signature: Option<String>,
    pub transaction_signature: Option<String>,
    pub severity: VulnerabilitySeverity,
    pub first_seen: DateTime<Utc>,
    pub instances: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectorConfig {
    pub enable_bytecode_analysis: bool,
    pub enable_transaction_monitoring: bool,
    pub enable_audit_database_checks: bool,
    pub cache_duration_hours: u64,
    pub max_concurrent_analyses: usize,
    pub alert_threshold_score: u8,
}

impl Default for DetectorConfig {
    fn default() -> Self {
        Self {
            enable_bytecode_analysis: true,
            enable_transaction_monitoring: true,
            enable_audit_database_checks: true,
            cache_duration_hours: 24,
            max_concurrent_analyses: 10,
            alert_threshold_score: 70,
        }
    }
}

impl SmartContractVulnerabilityDetector {
    pub fn new(audit_databases: Vec<Box<dyn AuditDatabase>>) -> Self {
        Self {
            vulnerability_database: Arc::new(DashMap::new()),
            known_exploits: Arc::new(DashMap::new()),
            audit_databases,
            bytecode_analyzer: BytecodeAnalyzer::new(),
            transaction_monitor: TransactionPatternMonitor::new(),
            scoring_engine: VulnerabilityScoringEngine::new(),
            config: Arc::new(RwLock::new(DetectorConfig::default())),
        }
    }

    pub async fn analyze_contract(&self, request: ContractAnalysisRequest) -> Result<VulnerabilityReport, VulnerabilityDetectionError> {
        let start_time = std::time::Instant::now();
        info!("Starting vulnerability analysis for contract: {}", request.contract_address);

        // Check cache first
        if let Some(cached_report) = self.get_cached_report(&request.contract_address).await {
            debug!("Using cached vulnerability report for {}", request.contract_address);
            return Ok(cached_report);
        }

        let config = self.config.read().await;
        let mut vulnerabilities = Vec::new();
        let mut risk_factors = Vec::new();
        let mut data_sources = Vec::new();

        // 1. Bytecode Analysis
        if config.enable_bytecode_analysis {
            match self.bytecode_analyzer.analyze(&request.contract_address).await {
                Ok(mut bytecode_vulns) => {
                    vulnerabilities.append(&mut bytecode_vulns.vulnerabilities);
                    risk_factors.append(&mut bytecode_vulns.risk_factors);
                    data_sources.push("bytecode_analysis".to_string());
                }
                Err(e) => {
                    warn!("Bytecode analysis failed for {}: {}", request.contract_address, e);
                }
            }
        }

        // 2. Transaction Pattern Analysis
        if config.enable_transaction_monitoring {
            match self.transaction_monitor.analyze_patterns(&request.contract_address).await {
                Ok(mut pattern_vulns) => {
                    vulnerabilities.append(&mut pattern_vulns.vulnerabilities);
                    risk_factors.append(&mut pattern_vulns.risk_factors);
                    data_sources.push("transaction_patterns".to_string());
                }
                Err(e) => {
                    warn!("Transaction pattern analysis failed for {}: {}", request.contract_address, e);
                }
            }
        }

        // 3. Audit Database Checks
        if config.enable_audit_database_checks {
            for audit_db in &self.audit_databases {
                match audit_db.check_contract(&request.contract_address).await {
                    Ok(mut audit_vulns) => {
                        vulnerabilities.append(&mut audit_vulns);
                        data_sources.push(format!("audit_db_{}", audit_db.name()));
                    }
                    Err(e) => {
                        warn!("Audit database check failed for {}: {}", request.contract_address, e);
                    }
                }
            }
        }

        // 4. Known Exploit Pattern Matching
        let exploit_matches = self.check_known_exploits(&request.contract_address).await;
        for exploit in exploit_matches {
            vulnerabilities.push(Vulnerability {
                id: format!("exploit_{}", exploit.pattern_id),
                severity: exploit.severity.clone(),
                category: VulnerabilityCategory::Other("Known Exploit Pattern".to_string()),
                description: format!("Contract matches known exploit pattern: {}", exploit.name),
                impact: exploit.description.clone(),
                confidence: 95,
                cvss_score: None,
                cwe_id: None,
                affected_functions: vec![],
                proof_of_concept: None,
                remediation: Some("Review contract for known vulnerability patterns".to_string()),
            });
        }

        // 5. Generate comprehensive risk assessment
        let analysis_duration = start_time.elapsed();
        let (risk_score, confidence_score) = self.scoring_engine.calculate_scores(&vulnerabilities, &risk_factors);
        
        let recommendations = self.generate_recommendations(&vulnerabilities, &risk_factors);

        let report = VulnerabilityReport {
            contract_address: request.contract_address.clone(),
            risk_score,
            confidence_score,
            vulnerabilities,
            risk_factors,
            recommendations,
            analysis_metadata: AnalysisMetadata {
                analyzed_at: Utc::now(),
                analysis_version: "1.0.0".to_string(),
                contract_size_bytes: None, // Would be filled by bytecode analyzer
                functions_analyzed: 0, // Would be filled by bytecode analyzer
                analysis_duration_ms: analysis_duration.as_millis() as u64,
                data_sources,
                compiler_version: None,
                is_verified: false,
            },
        };

        // Cache the result
        self.cache_report(&request.contract_address, &report).await;

        // Generate alerts if necessary
        if risk_score >= config.alert_threshold_score {
            self.generate_vulnerability_alert(&request, &report).await;
        }

        info!("Vulnerability analysis completed for {} in {}ms with risk score: {}", 
              request.contract_address, analysis_duration.as_millis(), risk_score);

        Ok(report)
    }

    async fn get_cached_report(&self, contract_address: &str) -> Option<VulnerabilityReport> {
        self.vulnerability_database.get(contract_address).map(|r| r.clone())
    }

    async fn cache_report(&self, contract_address: &str, report: &VulnerabilityReport) {
        self.vulnerability_database.insert(contract_address.to_string(), report.clone());
    }

    async fn check_known_exploits(&self, contract_address: &str) -> Vec<ExploitPattern> {
        // In a real implementation, this would check contract bytecode against known exploit patterns
        // For now, return empty vector
        vec![]
    }

    async fn generate_vulnerability_alert(&self, request: &ContractAnalysisRequest, report: &VulnerabilityReport) {
        let critical_vulns = report.vulnerabilities.iter()
            .filter(|v| v.severity == VulnerabilitySeverity::Critical)
            .count();

        let high_vulns = report.vulnerabilities.iter()
            .filter(|v| v.severity == VulnerabilitySeverity::High)
            .count();

        let risk_level = if critical_vulns > 0 {
            RiskLevel::Critical
        } else if high_vulns > 0 {
            RiskLevel::Warning
        } else {
            RiskLevel::Safe
        };

        let message = format!(
            "Smart contract vulnerability scan for {} found {} critical and {} high severity issues. Risk score: {}/100",
            request.contract_address, critical_vulns, high_vulns, report.risk_score
        );

        // In a real implementation, this would send alerts through the alert system
        info!("Vulnerability alert: {}", message);
    }

    fn generate_recommendations(&self, vulnerabilities: &[Vulnerability], risk_factors: &[RiskFactor]) -> Vec<SecurityRecommendation> {
        let mut recommendations = Vec::new();

        // Generate recommendations based on found vulnerabilities
        for vulnerability in vulnerabilities {
            match vulnerability.category {
                VulnerabilityCategory::Reentrancy => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Critical,
                        category: "Reentrancy Protection".to_string(),
                        title: "Implement Reentrancy Guards".to_string(),
                        description: "Add reentrancy protection to all external functions that modify state".to_string(),
                        implementation_effort: ImplementationEffort::Medium,
                        impact_reduction: 90,
                    });
                }
                VulnerabilityCategory::AccessControl => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::High,
                        category: "Access Control".to_string(),
                        title: "Strengthen Access Controls".to_string(),
                        description: "Review and strengthen access control mechanisms".to_string(),
                        implementation_effort: ImplementationEffort::Medium,
                        impact_reduction: 80,
                    });
                }
                VulnerabilityCategory::Oracle => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::High,
                        category: "Oracle Security".to_string(),
                        title: "Implement Oracle Validation".to_string(),
                        description: "Add price feed validation and circuit breakers".to_string(),
                        implementation_effort: ImplementationEffort::High,
                        impact_reduction: 85,
                    });
                }
                _ => {}
            }
        }

        // Generate recommendations based on risk factors
        for risk_factor in risk_factors {
            match risk_factor.factor_type {
                RiskFactorType::CodeComplexity if risk_factor.score > 70 => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Medium,
                        category: "Code Quality".to_string(),
                        title: "Reduce Code Complexity".to_string(),
                        description: "Refactor complex functions to improve readability and security".to_string(),
                        implementation_effort: ImplementationEffort::High,
                        impact_reduction: 40,
                    });
                }
                RiskFactorType::ExternalDependencies if risk_factor.score > 60 => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Medium,
                        category: "Dependencies".to_string(),
                        title: "Audit External Dependencies".to_string(),
                        description: "Review and audit all external contract dependencies".to_string(),
                        implementation_effort: ImplementationEffort::Medium,
                        impact_reduction: 60,
                    });
                }
                _ => {}
            }
        }

        recommendations
    }

    pub async fn start_continuous_monitoring(&self) -> Result<(), VulnerabilityDetectionError> {
        info!("Starting continuous vulnerability monitoring");
        
        // Start background monitoring tasks
        tokio::spawn(self.clone().monitor_new_exploits());
        tokio::spawn(self.clone().update_vulnerability_database());
        
        Ok(())
    }

    async fn monitor_new_exploits(self: Arc<Self>) {
        let mut interval = tokio::time::interval(Duration::from_secs(3600)); // Check hourly
        
        loop {
            interval.tick().await;
            if let Err(e) = self.update_exploit_patterns().await {
                error!("Failed to update exploit patterns: {}", e);
            }
        }
    }

    async fn update_vulnerability_database(self: Arc<Self>) {
        let mut interval = tokio::time::interval(Duration::from_secs(86400)); // Check daily
        
        loop {
            interval.tick().await;
            if let Err(e) = self.cleanup_expired_reports().await {
                error!("Failed to cleanup expired reports: {}", e);
            }
        }
    }

    async fn update_exploit_patterns(&self) -> Result<(), VulnerabilityDetectionError> {
        // In a real implementation, this would fetch latest exploit patterns from threat intel feeds
        debug!("Updating exploit patterns from threat intelligence sources");
        Ok(())
    }

    async fn cleanup_expired_reports(&self) -> Result<(), VulnerabilityDetectionError> {
        let config = self.config.read().await;
        let cutoff_time = Utc::now() - chrono::Duration::hours(config.cache_duration_hours as i64);
        
        let expired_keys: Vec<String> = self.vulnerability_database
            .iter()
            .filter(|entry| entry.value().analysis_metadata.analyzed_at < cutoff_time)
            .map(|entry| entry.key().clone())
            .collect();

        for key in expired_keys {
            self.vulnerability_database.remove(&key);
        }

        debug!("Cleaned up expired vulnerability reports");
        Ok(())
    }
}

impl Clone for SmartContractVulnerabilityDetector {
    fn clone(&self) -> Self {
        Self {
            vulnerability_database: self.vulnerability_database.clone(),
            known_exploits: self.known_exploits.clone(),
            audit_databases: vec![], // Note: Can't clone trait objects easily
            bytecode_analyzer: self.bytecode_analyzer.clone(),
            transaction_monitor: self.transaction_monitor.clone(),
            scoring_engine: self.scoring_engine.clone(),
            config: self.config.clone(),
        }
    }
}

#[derive(thiserror::Error, Debug)]
pub enum VulnerabilityDetectionError {
    #[error("Contract analysis failed: {message}")]
    AnalysisFailed { message: String },
    #[error("Bytecode not found for contract: {address}")]
    BytecodeNotFound { address: String },
    #[error("Network error: {0}")]
    NetworkError(#[from] reqwest::Error),
    #[error("Database error: {message}")]
    DatabaseError { message: String },
    #[error("Configuration error: {message}")]
    ConfigError { message: String },
}

// Supporting structures for analysis components
pub struct BytecodeAnalyzer {
    // Analysis engine for smart contract bytecode
}

impl BytecodeAnalyzer {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn analyze(&self, _contract_address: &str) -> Result<BytecodeAnalysisResult, VulnerabilityDetectionError> {
        // Placeholder for bytecode analysis
        // Real implementation would analyze EVM bytecode for vulnerability patterns
        Ok(BytecodeAnalysisResult {
            vulnerabilities: vec![],
            risk_factors: vec![],
        })
    }
}

impl Clone for BytecodeAnalyzer {
    fn clone(&self) -> Self {
        Self::new()
    }
}

pub struct BytecodeAnalysisResult {
    pub vulnerabilities: Vec<Vulnerability>,
    pub risk_factors: Vec<RiskFactor>,
}

pub struct TransactionPatternMonitor {
    // Monitor for unusual transaction patterns
}

impl TransactionPatternMonitor {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn analyze_patterns(&self, _contract_address: &str) -> Result<TransactionAnalysisResult, VulnerabilityDetectionError> {
        // Placeholder for transaction pattern analysis
        // Real implementation would analyze transaction history for suspicious patterns
        Ok(TransactionAnalysisResult {
            vulnerabilities: vec![],
            risk_factors: vec![],
        })
    }
}

impl Clone for TransactionPatternMonitor {
    fn clone(&self) -> Self {
        Self::new()
    }
}

pub struct TransactionAnalysisResult {
    pub vulnerabilities: Vec<Vulnerability>,
    pub risk_factors: Vec<RiskFactor>,
}

pub struct VulnerabilityScoringEngine {
    // Engine for calculating composite vulnerability scores
}

impl VulnerabilityScoringEngine {
    pub fn new() -> Self {
        Self {}
    }

    pub fn calculate_scores(&self, vulnerabilities: &[Vulnerability], risk_factors: &[RiskFactor]) -> (u8, u8) {
        // Calculate composite risk score
        let vuln_score = if vulnerabilities.is_empty() {
            0
        } else {
            let total_score: u32 = vulnerabilities.iter()
                .map(|v| v.severity.score() as u32 * v.confidence as u32 / 100)
                .sum();
            let avg_score = total_score / vulnerabilities.len() as u32;
            std::cmp::min(avg_score, 100) as u8
        };

        // Calculate risk factor score
        let risk_score = if risk_factors.is_empty() {
            0
        } else {
            let weighted_score: f32 = risk_factors.iter()
                .map(|rf| rf.score as f32 * rf.weight)
                .sum();
            let avg_risk = weighted_score / risk_factors.len() as f32;
            std::cmp::min(avg_risk as u8, 100)
        };

        // Combine scores with weights
        let final_score = ((vuln_score as f32 * 0.7) + (risk_score as f32 * 0.3)) as u8;
        let confidence = if vulnerabilities.is_empty() && risk_factors.is_empty() {
            50 // Medium confidence when no data
        } else {
            80 // High confidence when we have data
        };

        (final_score, confidence)
    }
}

impl Clone for VulnerabilityScoringEngine {
    fn clone(&self) -> Self {
        Self::new()
    }
}

#[async_trait]
pub trait AuditDatabase: Send + Sync {
    async fn check_contract(&self, contract_address: &str) -> Result<Vec<Vulnerability>, Box<dyn std::error::Error + Send + Sync>>;
    fn name(&self) -> String;
}