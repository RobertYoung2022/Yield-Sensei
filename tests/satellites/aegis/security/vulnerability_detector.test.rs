use tokio_test;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{Utc, Duration};
use async_trait::async_trait;

// Import Aegis satellite types and components
// Note: These imports will need to be adjusted based on the actual module structure
#[allow(dead_code)]
mod aegis_types {
    use serde::{Deserialize, Serialize};
    use chrono::{DateTime, Utc};
    use async_trait::async_trait;
    
    pub type PositionId = u64;
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct VulnerabilityReport {
        pub contract_address: String,
        pub risk_score: u8, // 0-100
        pub confidence_score: u8, // 0-100
        pub vulnerabilities: Vec<Vulnerability>,
        pub risk_factors: Vec<RiskFactor>,
        pub recommendations: Vec<SecurityRecommendation>,
        pub analysis_metadata: AnalysisMetadata,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Vulnerability {
        pub id: String,
        pub severity: VulnerabilitySeverity,
        pub category: VulnerabilityCategory,
        pub description: String,
        pub impact: String,
        pub confidence: u8, // 0-100
        pub cvss_score: Option<f32>,
        pub cwe_id: Option<String>,
        pub affected_functions: Vec<String>,
        pub proof_of_concept: Option<String>,
        pub remediation: Option<String>,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct RiskFactor {
        pub factor_type: RiskFactorType,
        pub weight: f32, // 0.0-1.0
        pub score: u8, // 0-100
        pub description: String,
        pub evidence: Vec<String>,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum RiskFactorType {
        CodeComplexity,
        ExternalDependencies,
        PrivilegeEscalation,
        DataExposure,
        BusinessLogic,
        GasOptimization,
        Upgradeability,
        Governance,
        Oracle,
        Liquidation,
        Flashloan,
        CrossChain,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct SecurityRecommendation {
        pub priority: RecommendationPriority,
        pub category: String,
        pub title: String,
        pub description: String,
        pub implementation_effort: ImplementationEffort,
        pub impact_reduction: u8, // 0-100
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum RecommendationPriority {
        Critical,
        High,
        Medium,
        Low,
        Informational,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum ImplementationEffort {
        Low,
        Medium,
        High,
        Extreme,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct AnalysisMetadata {
        pub analyzed_at: DateTime<Utc>,
        pub analysis_version: String,
        pub contract_size_bytes: Option<usize>,
        pub functions_analyzed: usize,
        pub analysis_duration_ms: u64,
        pub data_sources: Vec<String>,
        pub compiler_version: Option<String>,
        pub is_verified: bool,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
    pub enum VulnerabilitySeverity {
        Info,
        Low,
        Medium,
        High,
        Critical,
    }
    
    impl VulnerabilitySeverity {
        pub fn score(&self) -> u8 {
            match self {
                VulnerabilitySeverity::Info => 10,
                VulnerabilitySeverity::Low => 25,
                VulnerabilitySeverity::Medium => 50,
                VulnerabilitySeverity::High => 75,
                VulnerabilitySeverity::Critical => 95,
            }
        }
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
    pub enum VulnerabilityCategory {
        Reentrancy,
        IntegerOverflow,
        AccessControl,
        Oracle,
        Logic,
        Governance,
        Upgradeability,
        Denial,
        Information,
        Flashloan,
        MEV,
        Liquidation,
        CrossChain,
        GasGriefing,
        TimeLock,
        Signature,
        Other(String),
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ContractAnalysisRequest {
        pub contract_address: String,
        pub chain_id: u64,
        pub priority: AnalysisPriority,
        pub requested_by: Option<String>,
        pub position_ids: Vec<PositionId>,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AnalysisPriority {
        Low,
        Normal,
        High,
        Critical,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ExploitPattern {
        pub pattern_id: String,
        pub name: String,
        pub description: String,
        pub bytecode_signature: Option<String>,
        pub transaction_signature: Option<String>,
        pub severity: VulnerabilitySeverity,
        pub first_seen: DateTime<Utc>,
        pub instances: u32,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct DetectorConfig {
        pub enable_bytecode_analysis: bool,
        pub enable_transaction_monitoring: bool,
        pub enable_audit_database_checks: bool,
        pub cache_duration_hours: u64,
        pub max_concurrent_analyses: usize,
        pub alert_threshold_score: u8,
    }
    
    impl Default for DetectorConfig {
        fn default() -> Self {
            Self {
                enable_bytecode_analysis: true,
                enable_transaction_monitoring: true,
                enable_audit_database_checks: true,
                cache_duration_hours: 24,
                max_concurrent_analyses: 10,
                alert_threshold_score: 70,
            }
        }
    }
    
    #[derive(thiserror::Error, Debug)]
    pub enum VulnerabilityDetectionError {
        #[error("Contract analysis failed: {message}")]
        AnalysisFailed { message: String },
        #[error("Bytecode not found for contract: {address}")]
        BytecodeNotFound { address: String },
        #[error("Database error: {message}")]
        DatabaseError { message: String },
        #[error("Configuration error: {message}")]
        ConfigError { message: String },
    }
    
    #[derive(Debug, Clone)]
    pub struct VulnerabilityMetrics {
        pub total_contracts_analyzed: u64,
        pub high_risk_contracts: u64,
        pub critical_vulnerabilities_found: u64,
        pub false_positive_rate: f64,
        pub false_negative_rate: f64,
        pub average_analysis_time_ms: f64,
        pub cache_hit_rate: f64,
        pub detection_accuracy: f64,
    }
    
    #[async_trait]
    pub trait AuditDatabase: Send + Sync {
        async fn check_contract(&self, contract_address: &str) -> Result<Vec<Vulnerability>, Box<dyn std::error::Error + Send + Sync>>;
        fn name(&self) -> String;
    }
}

use aegis_types::*;

/// Mock vulnerability detector for testing
pub struct MockVulnerabilityDetector {
    vulnerability_cache: Arc<RwLock<HashMap<String, VulnerabilityReport>>>,
    known_vulnerabilities: Arc<RwLock<HashMap<String, Vec<Vulnerability>>>>,
    exploit_patterns: Arc<RwLock<HashMap<String, ExploitPattern>>>,
    config: DetectorConfig,
    metrics: Arc<RwLock<VulnerabilityMetrics>>,
    audit_databases: Vec<Box<dyn AuditDatabase>>,
}

impl MockVulnerabilityDetector {
    fn new(config: DetectorConfig) -> Self {
        Self {
            vulnerability_cache: Arc::new(RwLock::new(HashMap::new())),
            known_vulnerabilities: Arc::new(RwLock::new(HashMap::new())),
            exploit_patterns: Arc::new(RwLock::new(HashMap::new())),
            config,
            metrics: Arc::new(RwLock::new(VulnerabilityMetrics {
                total_contracts_analyzed: 0,
                high_risk_contracts: 0,
                critical_vulnerabilities_found: 0,
                false_positive_rate: 0.0,
                false_negative_rate: 0.0,
                average_analysis_time_ms: 0.0,
                cache_hit_rate: 0.0,
                detection_accuracy: 0.0,
            })),
            audit_databases: vec![],
        }
    }
    
    fn with_audit_databases(mut self, databases: Vec<Box<dyn AuditDatabase>>) -> Self {
        self.audit_databases = databases;
        self
    }
    
    // Add known vulnerability data for testing
    async fn add_known_vulnerability(&self, contract_address: &str, vulnerability: Vulnerability) {
        let mut known_vulns = self.known_vulnerabilities.write().await;
        known_vulns.entry(contract_address.to_string())
            .or_insert_with(Vec::new)
            .push(vulnerability);
    }
    
    // Add exploit pattern for testing
    async fn add_exploit_pattern(&self, pattern_id: &str, pattern: ExploitPattern) {
        let mut patterns = self.exploit_patterns.write().await;
        patterns.insert(pattern_id.to_string(), pattern);
    }
    
    async fn analyze_contract(&self, request: ContractAnalysisRequest) -> Result<VulnerabilityReport, VulnerabilityDetectionError> {
        let start_time = std::time::Instant::now();
        
        // Check cache first
        if let Some(cached_report) = self.get_cached_report(&request.contract_address).await {
            self.update_cache_hit_metrics().await;
            return Ok(cached_report);
        }
        
        let mut vulnerabilities = Vec::new();
        let mut risk_factors = Vec::new();
        let mut data_sources = Vec::new();
        
        // 1. Check known vulnerabilities (simulates bytecode analysis)
        if self.config.enable_bytecode_analysis {
            if let Some(known_vulns) = self.get_known_vulnerabilities(&request.contract_address).await {
                vulnerabilities.extend(known_vulns);
                data_sources.push("bytecode_analysis".to_string());
                
                // Add some risk factors based on vulnerabilities
                for vuln in &vulnerabilities {
                    match vuln.category {
                        VulnerabilityCategory::Reentrancy => {
                            risk_factors.push(RiskFactor {
                                factor_type: RiskFactorType::BusinessLogic,
                                weight: 0.8,
                                score: 85,
                                description: "Reentrancy vulnerability indicates complex state management".to_string(),
                                evidence: vec!["Reentrancy pattern detected in bytecode".to_string()],
                            });
                        }
                        VulnerabilityCategory::Oracle => {
                            risk_factors.push(RiskFactor {
                                factor_type: RiskFactorType::Oracle,
                                weight: 0.9,
                                score: 80,
                                description: "Oracle dependency creates external risk".to_string(),
                                evidence: vec!["Oracle price feed dependency detected".to_string()],
                            });
                        }
                        _ => {}
                    }
                }
            }
        }
        
        // 2. Check transaction patterns (simulated)
        if self.config.enable_transaction_monitoring {
            let transaction_risks = self.analyze_transaction_patterns(&request.contract_address).await;
            risk_factors.extend(transaction_risks);
            data_sources.push("transaction_patterns".to_string());
        }
        
        // 3. Check audit databases
        if self.config.enable_audit_database_checks {
            for audit_db in &self.audit_databases {
                if let Ok(audit_vulns) = audit_db.check_contract(&request.contract_address).await {
                    vulnerabilities.extend(audit_vulns);
                    data_sources.push(format!("audit_db_{}", audit_db.name()));
                }
            }
        }
        
        // 4. Check for known exploit patterns
        let exploit_matches = self.check_exploit_patterns(&request.contract_address).await;
        for pattern in exploit_matches {
            vulnerabilities.push(Vulnerability {
                id: format!("exploit_{}", pattern.pattern_id),
                severity: pattern.severity.clone(),
                category: VulnerabilityCategory::Other("Known Exploit".to_string()),
                description: format!("Contract matches exploit pattern: {}", pattern.name),
                impact: pattern.description.clone(),
                confidence: 95,
                cvss_score: None,
                cwe_id: None,
                affected_functions: vec![],
                proof_of_concept: None,
                remediation: Some("Review and patch known vulnerability".to_string()),
            });
        }
        
        // 5. Calculate risk scores
        let (risk_score, confidence_score) = self.calculate_scores(&vulnerabilities, &risk_factors);
        
        // 6. Generate recommendations
        let recommendations = self.generate_recommendations(&vulnerabilities, &risk_factors);
        
        let analysis_duration = start_time.elapsed();
        
        let report = VulnerabilityReport {
            contract_address: request.contract_address.clone(),
            risk_score,
            confidence_score,
            vulnerabilities,
            risk_factors,
            recommendations,
            analysis_metadata: AnalysisMetadata {
                analyzed_at: Utc::now(),
                analysis_version: "1.0.0".to_string(),
                contract_size_bytes: Some(self.estimate_contract_size(&request.contract_address)),
                functions_analyzed: self.estimate_functions_count(&request.contract_address),
                analysis_duration_ms: analysis_duration.as_millis() as u64,
                data_sources,
                compiler_version: Some("0.8.19".to_string()),
                is_verified: true,
            },
        };
        
        // Cache the result
        self.cache_report(&request.contract_address, &report).await;
        
        // Update metrics
        self.update_analysis_metrics(&report, analysis_duration).await;
        
        Ok(report)
    }
    
    async fn get_cached_report(&self, contract_address: &str) -> Option<VulnerabilityReport> {
        let cache = self.vulnerability_cache.read().await;
        if let Some(report) = cache.get(contract_address) {
            // Check if report is still valid
            let cutoff_time = Utc::now() - Duration::hours(self.config.cache_duration_hours as i64);
            if report.analysis_metadata.analyzed_at > cutoff_time {
                return Some(report.clone());
            }
        }
        None
    }
    
    async fn cache_report(&self, contract_address: &str, report: &VulnerabilityReport) {
        let mut cache = self.vulnerability_cache.write().await;
        cache.insert(contract_address.to_string(), report.clone());
    }
    
    async fn get_known_vulnerabilities(&self, contract_address: &str) -> Option<Vec<Vulnerability>> {
        let known_vulns = self.known_vulnerabilities.read().await;
        known_vulns.get(contract_address).cloned()
    }
    
    async fn analyze_transaction_patterns(&self, contract_address: &str) -> Vec<RiskFactor> {
        let mut risk_factors = Vec::new();
        
        // Simulate transaction pattern analysis
        match contract_address {
            addr if addr.contains("flash") => {
                risk_factors.push(RiskFactor {
                    factor_type: RiskFactorType::Flashloan,
                    weight: 0.7,
                    score: 75,
                    description: "High frequency of flashloan transactions detected".to_string(),
                    evidence: vec!["Flashloan pattern in transaction history".to_string()],
                });
            }
            addr if addr.contains("governance") => {
                risk_factors.push(RiskFactor {
                    factor_type: RiskFactorType::Governance,
                    weight: 0.6,
                    score: 60,
                    description: "Governance-related transaction patterns".to_string(),
                    evidence: vec!["Governance voting patterns detected".to_string()],
                });
            }
            addr if addr.contains("complex") => {
                risk_factors.push(RiskFactor {
                    factor_type: RiskFactorType::CodeComplexity,
                    weight: 0.8,
                    score: 90,
                    description: "Complex interaction patterns suggest high code complexity".to_string(),
                    evidence: vec!["Multiple complex function calls per transaction".to_string()],
                });
            }
            _ => {}
        }
        
        risk_factors
    }
    
    async fn check_exploit_patterns(&self, contract_address: &str) -> Vec<ExploitPattern> {
        let patterns = self.exploit_patterns.read().await;
        let mut matches = Vec::new();
        
        // Simple pattern matching based on contract address characteristics
        for (_, pattern) in patterns.iter() {
            if contract_address.contains("exploit") || contract_address.contains("hack") {
                matches.push(pattern.clone());
            }
        }
        
        matches
    }
    
    fn calculate_scores(&self, vulnerabilities: &[Vulnerability], risk_factors: &[RiskFactor]) -> (u8, u8) {
        // Calculate vulnerability score
        let vuln_score = if vulnerabilities.is_empty() {
            0
        } else {
            let total_score: u32 = vulnerabilities.iter()
                .map(|v| v.severity.score() as u32 * v.confidence as u32 / 100)
                .sum();
            let avg_score = total_score / vulnerabilities.len() as u32;
            std::cmp::min(avg_score, 100) as u8
        };
        
        // Calculate risk factor score
        let risk_score = if risk_factors.is_empty() {
            0
        } else {
            let weighted_score: f32 = risk_factors.iter()
                .map(|rf| rf.score as f32 * rf.weight)
                .sum();
            let avg_risk = weighted_score / risk_factors.len() as f32;
            std::cmp::min(avg_risk as u8, 100)
        };
        
        // Combine scores with weights (70% vulnerability, 30% risk factors)
        let final_score = ((vuln_score as f32 * 0.7) + (risk_score as f32 * 0.3)) as u8;
        
        // Calculate confidence based on data sources and analysis depth
        let confidence = if vulnerabilities.is_empty() && risk_factors.is_empty() {
            50 // Medium confidence when no issues found
        } else if vulnerabilities.len() >= 3 || risk_factors.len() >= 5 {
            95 // High confidence with substantial evidence
        } else {
            80 // Good confidence with some evidence
        };
        
        (final_score, confidence)
    }
    
    fn generate_recommendations(&self, vulnerabilities: &[Vulnerability], risk_factors: &[RiskFactor]) -> Vec<SecurityRecommendation> {
        let mut recommendations = Vec::new();
        
        // Generate vulnerability-specific recommendations
        for vulnerability in vulnerabilities {
            match vulnerability.category {
                VulnerabilityCategory::Reentrancy => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Critical,
                        category: "Reentrancy Protection".to_string(),
                        title: "Implement Reentrancy Guards".to_string(),
                        description: "Add reentrancy protection using OpenZeppelin's ReentrancyGuard".to_string(),
                        implementation_effort: ImplementationEffort::Medium,
                        impact_reduction: 95,
                    });
                }
                VulnerabilityCategory::AccessControl => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::High,
                        category: "Access Control".to_string(),
                        title: "Strengthen Access Controls".to_string(),
                        description: "Implement role-based access control with proper modifiers".to_string(),
                        implementation_effort: ImplementationEffort::Medium,
                        impact_reduction: 85,
                    });
                }
                VulnerabilityCategory::Oracle => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::High,
                        category: "Oracle Security".to_string(),
                        title: "Implement Oracle Validation".to_string(),
                        description: "Add price feed validation, staleness checks, and circuit breakers".to_string(),
                        implementation_effort: ImplementationEffort::High,
                        impact_reduction: 90,
                    });
                }
                VulnerabilityCategory::Flashloan => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::High,
                        category: "Flashloan Protection".to_string(),
                        title: "Add Flashloan Attack Prevention".to_string(),
                        description: "Implement flashloan detection and protection mechanisms".to_string(),
                        implementation_effort: ImplementationEffort::High,
                        impact_reduction: 80,
                    });
                }
                VulnerabilityCategory::IntegerOverflow => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Medium,
                        category: "Integer Safety".to_string(),
                        title: "Use SafeMath or Solidity 0.8+".to_string(),
                        description: "Prevent integer overflow/underflow with safe arithmetic".to_string(),
                        implementation_effort: ImplementationEffort::Low,
                        impact_reduction: 100,
                    });
                }
                _ => {}
            }
        }
        
        // Generate risk factor-specific recommendations
        for risk_factor in risk_factors {
            match risk_factor.factor_type {
                RiskFactorType::CodeComplexity if risk_factor.score > 80 => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Medium,
                        category: "Code Quality".to_string(),
                        title: "Reduce Code Complexity".to_string(),
                        description: "Refactor complex functions and improve code readability".to_string(),
                        implementation_effort: ImplementationEffort::High,
                        impact_reduction: 40,
                    });
                }
                RiskFactorType::ExternalDependencies if risk_factor.score > 70 => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Medium,
                        category: "Dependency Management".to_string(),
                        title: "Audit External Dependencies".to_string(),
                        description: "Review and audit all external contract dependencies".to_string(),
                        implementation_effort: ImplementationEffort::Medium,
                        impact_reduction: 60,
                    });
                }
                RiskFactorType::Governance if risk_factor.score > 60 => {
                    recommendations.push(SecurityRecommendation {
                        priority: RecommendationPriority::Medium,
                        category: "Governance Security".to_string(),
                        title: "Improve Governance Security".to_string(),
                        description: "Implement timelock delays and multi-signature requirements".to_string(),
                        implementation_effort: ImplementationEffort::High,
                        impact_reduction: 70,
                    });
                }
                _ => {}
            }
        }
        
        // Sort by priority and impact
        recommendations.sort_by(|a, b| {
            match (&a.priority, &b.priority) {
                (RecommendationPriority::Critical, RecommendationPriority::Critical) => {
                    b.impact_reduction.cmp(&a.impact_reduction)
                }
                (RecommendationPriority::Critical, _) => std::cmp::Ordering::Less,
                (_, RecommendationPriority::Critical) => std::cmp::Ordering::Greater,
                (RecommendationPriority::High, RecommendationPriority::High) => {
                    b.impact_reduction.cmp(&a.impact_reduction)
                }
                (RecommendationPriority::High, _) => std::cmp::Ordering::Less,
                (_, RecommendationPriority::High) => std::cmp::Ordering::Greater,
                _ => b.impact_reduction.cmp(&a.impact_reduction),
            }
        });
        
        recommendations
    }
    
    fn estimate_contract_size(&self, contract_address: &str) -> usize {
        // Mock contract size estimation based on address characteristics
        match contract_address.len() {
            0..=10 => 1000,
            11..=20 => 5000,
            21..=30 => 15000,
            _ => 25000,
        }
    }
    
    fn estimate_functions_count(&self, contract_address: &str) -> usize {
        // Mock function count estimation
        self.estimate_contract_size(contract_address) / 200
    }
    
    async fn update_cache_hit_metrics(&self) {
        let mut metrics = self.metrics.write().await;
        // Simplified cache hit rate calculation
        metrics.cache_hit_rate = (metrics.cache_hit_rate * 0.9) + (1.0 * 0.1);
    }
    
    async fn update_analysis_metrics(&self, report: &VulnerabilityReport, duration: std::time::Duration) {
        let mut metrics = self.metrics.write().await;
        
        metrics.total_contracts_analyzed += 1;
        
        if report.risk_score >= 70 {
            metrics.high_risk_contracts += 1;
        }
        
        let critical_vulns = report.vulnerabilities.iter()
            .filter(|v| v.severity == VulnerabilitySeverity::Critical)
            .count() as u64;
        metrics.critical_vulnerabilities_found += critical_vulns;
        
        // Update average analysis time (running average)
        let new_time = duration.as_millis() as f64;
        metrics.average_analysis_time_ms = (metrics.average_analysis_time_ms * 0.9) + (new_time * 0.1);
        
        // Mock detection accuracy (would be calculated against ground truth in real system)
        metrics.detection_accuracy = 0.92; // 92% accuracy
        metrics.false_positive_rate = 0.05; // 5% false positive rate
        metrics.false_negative_rate = 0.08; // 8% false negative rate
    }
    
    async fn get_metrics(&self) -> VulnerabilityMetrics {
        self.metrics.read().await.clone()
    }
    
    async fn bulk_analyze(&self, requests: Vec<ContractAnalysisRequest>) -> Vec<Result<VulnerabilityReport, VulnerabilityDetectionError>> {
        let mut results = Vec::new();
        let max_concurrent = self.config.max_concurrent_analyses;
        
        // Process in batches to respect concurrency limits
        for chunk in requests.chunks(max_concurrent) {
            let mut batch_results = Vec::new();
            
            for request in chunk {
                let result = self.analyze_contract(request.clone()).await;
                batch_results.push(result);
            }
            
            results.extend(batch_results);
        }
        
        results
    }
    
    async fn clear_cache(&self) {
        let mut cache = self.vulnerability_cache.write().await;
        cache.clear();
    }
    
    async fn get_vulnerability_database_stats(&self) -> HashMap<String, u64> {
        let cache = self.vulnerability_cache.read().await;
        let mut stats = HashMap::new();
        
        stats.insert("total_cached_reports".to_string(), cache.len() as u64);
        
        let now = Utc::now();
        let fresh_count = cache.values()
            .filter(|report| {
                let age_hours = (now - report.analysis_metadata.analyzed_at).num_hours();
                age_hours < (self.config.cache_duration_hours as i64 / 2)
            })
            .count() as u64;
        
        stats.insert("fresh_reports".to_string(), fresh_count);
        stats.insert("stale_reports".to_string(), cache.len() as u64 - fresh_count);
        
        stats
    }
}

// Mock audit database implementations for testing
struct MockConsenSysDatabase;

#[async_trait]
impl AuditDatabase for MockConsenSysDatabase {
    async fn check_contract(&self, contract_address: &str) -> Result<Vec<Vulnerability>, Box<dyn std::error::Error + Send + Sync>> {
        let mut vulnerabilities = Vec::new();
        
        // Simulate finding vulnerabilities in certain contracts
        if contract_address.contains("consensys") {
            vulnerabilities.push(Vulnerability {
                id: "CS-001".to_string(),
                severity: VulnerabilitySeverity::Medium,
                category: VulnerabilityCategory::AccessControl,
                description: "Insufficient access control validation".to_string(),
                impact: "Unauthorized access to admin functions".to_string(),
                confidence: 85,
                cvss_score: Some(6.5),
                cwe_id: Some("CWE-284".to_string()),
                affected_functions: vec!["setAdmin".to_string(), "withdraw".to_string()],
                proof_of_concept: None,
                remediation: Some("Implement proper role-based access control".to_string()),
            });
        }
        
        Ok(vulnerabilities)
    }
    
    fn name(&self) -> String {
        "ConsenSys".to_string()
    }
}

struct MockTrailOfBitsDatabase;

#[async_trait]
impl AuditDatabase for MockTrailOfBitsDatabase {
    async fn check_contract(&self, contract_address: &str) -> Result<Vec<Vulnerability>, Box<dyn std::error::Error + Send + Sync>> {
        let mut vulnerabilities = Vec::new();
        
        if contract_address.contains("trail") {
            vulnerabilities.push(Vulnerability {
                id: "TOB-001".to_string(),
                severity: VulnerabilitySeverity::High,
                category: VulnerabilityCategory::Reentrancy,
                description: "Reentrancy vulnerability in withdraw function".to_string(),
                impact: "Potential fund drainage through reentrancy attack".to_string(),
                confidence: 95,
                cvss_score: Some(8.2),
                cwe_id: Some("CWE-362".to_string()),
                affected_functions: vec!["withdraw".to_string()],
                proof_of_concept: Some("Exploit contract available in test suite".to_string()),
                remediation: Some("Use reentrancy guard or checks-effects-interactions pattern".to_string()),
            });
        }
        
        Ok(vulnerabilities)
    }
    
    fn name(&self) -> String {
        "Trail of Bits".to_string()
    }
}

#[cfg(test)]
mod vulnerability_detector_tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_detector_creation() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        let metrics = detector.get_metrics().await;
        assert_eq!(metrics.total_contracts_analyzed, 0);
        assert_eq!(metrics.high_risk_contracts, 0);
        assert_eq!(metrics.critical_vulnerabilities_found, 0);
    }
    
    #[tokio::test]
    async fn test_clean_contract_analysis() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        let request = ContractAnalysisRequest {
            contract_address: "0x1234567890abcdef".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: Some("test".to_string()),
            position_ids: vec![1, 2, 3],
        };
        
        let report = detector.analyze_contract(request).await.unwrap();
        
        assert_eq!(report.contract_address, "0x1234567890abcdef");
        assert_eq!(report.vulnerabilities.len(), 0);
        assert!(report.risk_score < 30); // Should be low risk for clean contract
        assert!(report.confidence_score >= 50);
        assert!(!report.recommendations.is_empty() || report.vulnerabilities.is_empty());
        assert!(report.analysis_metadata.analysis_duration_ms > 0);
    }
    
    #[tokio::test]
    async fn test_reentrancy_vulnerability_detection() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        // Add a known reentrancy vulnerability
        let reentrancy_vuln = Vulnerability {
            id: "REEN-001".to_string(),
            severity: VulnerabilitySeverity::Critical,
            category: VulnerabilityCategory::Reentrancy,
            description: "Reentrancy vulnerability in withdraw function".to_string(),
            impact: "Attacker can drain contract funds".to_string(),
            confidence: 95,
            cvss_score: Some(9.8),
            cwe_id: Some("CWE-362".to_string()),
            affected_functions: vec!["withdraw".to_string()],
            proof_of_concept: Some("PoC available".to_string()),
            remediation: Some("Use reentrancy guard".to_string()),
        };
        
        detector.add_known_vulnerability("0xreentrancy", reentrancy_vuln).await;
        
        let request = ContractAnalysisRequest {
            contract_address: "0xreentrancy".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::High,
            requested_by: Some("security_team".to_string()),
            position_ids: vec![],
        };
        
        let report = detector.analyze_contract(request).await.unwrap();
        
        assert_eq!(report.vulnerabilities.len(), 1);
        assert_eq!(report.vulnerabilities[0].category, VulnerabilityCategory::Reentrancy);
        assert_eq!(report.vulnerabilities[0].severity, VulnerabilitySeverity::Critical);
        assert!(report.risk_score >= 80); // Should be high risk
        
        // Should have reentrancy-specific recommendations
        let reentrancy_recommendations: Vec<_> = report.recommendations.iter()
            .filter(|r| r.category.contains("Reentrancy"))
            .collect();
        assert!(!reentrancy_recommendations.is_empty());
        assert_eq!(reentrancy_recommendations[0].priority, RecommendationPriority::Critical);
    }
    
    #[tokio::test]
    async fn test_oracle_vulnerability_detection() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        let oracle_vuln = Vulnerability {
            id: "ORACLE-001".to_string(),
            severity: VulnerabilitySeverity::High,
            category: VulnerabilityCategory::Oracle,
            description: "Price manipulation vulnerability through oracle".to_string(),
            impact: "Price manipulation can lead to unfair liquidations".to_string(),
            confidence: 80,
            cvss_score: Some(7.5),
            cwe_id: None,
            affected_functions: vec!["getPrice".to_string(), "liquidate".to_string()],
            proof_of_concept: None,
            remediation: Some("Implement multiple oracle sources and validation".to_string()),
        };
        
        detector.add_known_vulnerability("0xoracle", oracle_vuln).await;
        
        let request = ContractAnalysisRequest {
            contract_address: "0xoracle".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::High,
            requested_by: None,
            position_ids: vec![10, 20],
        };
        
        let report = detector.analyze_contract(request).await.unwrap();
        
        assert_eq!(report.vulnerabilities.len(), 1);
        assert_eq!(report.vulnerabilities[0].category, VulnerabilityCategory::Oracle);
        assert!(report.risk_score >= 60);
        
        // Should have oracle-specific risk factors
        let oracle_risk_factors: Vec<_> = report.risk_factors.iter()
            .filter(|rf| rf.factor_type == RiskFactorType::Oracle)
            .collect();
        assert!(!oracle_risk_factors.is_empty());
        
        // Should have oracle-specific recommendations
        let oracle_recommendations: Vec<_> = report.recommendations.iter()
            .filter(|r| r.category.contains("Oracle"))
            .collect();
        assert!(!oracle_recommendations.is_empty());
    }
    
    #[tokio::test]
    async fn test_multiple_vulnerabilities() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        // Add multiple vulnerabilities
        let vulnerabilities = vec![
            Vulnerability {
                id: "MULTI-001".to_string(),
                severity: VulnerabilitySeverity::Critical,
                category: VulnerabilityCategory::Reentrancy,
                description: "Reentrancy in withdraw".to_string(),
                impact: "Fund drainage".to_string(),
                confidence: 95,
                cvss_score: Some(9.8),
                cwe_id: Some("CWE-362".to_string()),
                affected_functions: vec!["withdraw".to_string()],
                proof_of_concept: None,
                remediation: Some("Use reentrancy guard".to_string()),
            },
            Vulnerability {
                id: "MULTI-002".to_string(),
                severity: VulnerabilitySeverity::High,
                category: VulnerabilityCategory::AccessControl,
                description: "Missing access control".to_string(),
                impact: "Unauthorized access".to_string(),
                confidence: 85,
                cvss_score: Some(8.0),
                cwe_id: Some("CWE-284".to_string()),
                affected_functions: vec!["setAdmin".to_string()],
                proof_of_concept: None,
                remediation: Some("Add proper access control".to_string()),
            },
            Vulnerability {
                id: "MULTI-003".to_string(),
                severity: VulnerabilitySeverity::Medium,
                category: VulnerabilityCategory::IntegerOverflow,
                description: "Potential integer overflow".to_string(),
                impact: "Arithmetic errors".to_string(),
                confidence: 70,
                cvss_score: Some(5.5),
                cwe_id: Some("CWE-190".to_string()),
                affected_functions: vec!["calculate".to_string()],
                proof_of_concept: None,
                remediation: Some("Use SafeMath".to_string()),
            },
        ];
        
        for vuln in vulnerabilities {
            detector.add_known_vulnerability("0xmultiple", vuln).await;
        }
        
        let request = ContractAnalysisRequest {
            contract_address: "0xmultiple".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Critical,
            requested_by: Some("audit_team".to_string()),
            position_ids: vec![],
        };
        
        let report = detector.analyze_contract(request).await.unwrap();
        
        assert_eq!(report.vulnerabilities.len(), 3);
        assert!(report.risk_score >= 85); // Should be very high risk
        assert!(report.confidence_score >= 90); // High confidence with multiple findings
        
        // Should have multiple recommendations
        assert!(report.recommendations.len() >= 3);
        
        // Check that recommendations are sorted by priority
        let critical_recs = report.recommendations.iter()
            .filter(|r| r.priority == RecommendationPriority::Critical)
            .count();
        assert!(critical_recs > 0);
        
        // Verify analysis metadata
        assert!(report.analysis_metadata.functions_analyzed > 0);
        assert!(report.analysis_metadata.contract_size_bytes.is_some());
        assert!(!report.analysis_metadata.data_sources.is_empty());
    }
    
    #[tokio::test]
    async fn test_audit_database_integration() {
        let config = DetectorConfig::default();
        
        let audit_databases: Vec<Box<dyn AuditDatabase>> = vec![
            Box::new(MockConsenSysDatabase),
            Box::new(MockTrailOfBitsDatabase),
        ];
        
        let detector = MockVulnerabilityDetector::new(config).with_audit_databases(audit_databases);
        
        // Test contract that should trigger ConsenSys database
        let request1 = ContractAnalysisRequest {
            contract_address: "0xconsenSysContract".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: None,
            position_ids: vec![],
        };
        
        let report1 = detector.analyze_contract(request1).await.unwrap();
        
        assert!(report1.vulnerabilities.len() > 0);
        let consensys_vuln = report1.vulnerabilities.iter()
            .find(|v| v.id.starts_with("CS-"));
        assert!(consensys_vuln.is_some());
        
        // Test contract that should trigger Trail of Bits database
        let request2 = ContractAnalysisRequest {
            contract_address: "0xtrailContract".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: None,
            position_ids: vec![],
        };
        
        let report2 = detector.analyze_contract(request2).await.unwrap();
        
        assert!(report2.vulnerabilities.len() > 0);
        let tob_vuln = report2.vulnerabilities.iter()
            .find(|v| v.id.starts_with("TOB-"));
        assert!(tob_vuln.is_some());
        assert_eq!(tob_vuln.unwrap().severity, VulnerabilitySeverity::High);
    }
    
    #[tokio::test]
    async fn test_exploit_pattern_matching() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        // Add known exploit pattern
        let exploit_pattern = ExploitPattern {
            pattern_id: "EXPLOIT-001".to_string(),
            name: "Flash Loan Attack".to_string(),
            description: "Common flash loan manipulation pattern".to_string(),
            bytecode_signature: Some("0x1234abcd".to_string()),
            transaction_signature: Some("flashLoan(uint256,address,bytes)".to_string()),
            severity: VulnerabilitySeverity::Critical,
            first_seen: Utc::now() - Duration::days(30),
            instances: 15,
        };
        
        detector.add_exploit_pattern("flash_exploit", exploit_pattern).await;
        
        let request = ContractAnalysisRequest {
            contract_address: "0xexploitContract".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::High,
            requested_by: Some("monitoring_system".to_string()),
            position_ids: vec![],
        };
        
        let report = detector.analyze_contract(request).await.unwrap();
        
        // Should detect the exploit pattern
        let exploit_vulns: Vec<_> = report.vulnerabilities.iter()
            .filter(|v| v.id.starts_with("exploit_"))
            .collect();
        assert_eq!(exploit_vulns.len(), 1);
        assert_eq!(exploit_vulns[0].severity, VulnerabilitySeverity::Critical);
        assert_eq!(exploit_vulns[0].confidence, 95);
    }
    
    #[tokio::test]
    async fn test_transaction_pattern_analysis() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        // Test flashloan pattern detection
        let request1 = ContractAnalysisRequest {
            contract_address: "0xflashContract".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: None,
            position_ids: vec![],
        };
        
        let report1 = detector.analyze_contract(request1).await.unwrap();
        
        let flashloan_risks: Vec<_> = report1.risk_factors.iter()
            .filter(|rf| rf.factor_type == RiskFactorType::Flashloan)
            .collect();
        assert!(!flashloan_risks.is_empty());
        assert!(flashloan_risks[0].score >= 70);
        
        // Test governance pattern detection
        let request2 = ContractAnalysisRequest {
            contract_address: "0xgovernanceContract".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: None,
            position_ids: vec![],
        };
        
        let report2 = detector.analyze_contract(request2).await.unwrap();
        
        let governance_risks: Vec<_> = report2.risk_factors.iter()
            .filter(|rf| rf.factor_type == RiskFactorType::Governance)
            .collect();
        assert!(!governance_risks.is_empty());
    }
    
    #[tokio::test]
    async fn test_caching_functionality() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        let request = ContractAnalysisRequest {
            contract_address: "0xcacheTest".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: None,
            position_ids: vec![],
        };
        
        // First analysis - should not be cached
        let start_time1 = std::time::Instant::now();
        let report1 = detector.analyze_contract(request.clone()).await.unwrap();
        let duration1 = start_time1.elapsed();
        
        // Second analysis - should be cached and faster
        let start_time2 = std::time::Instant::now();
        let report2 = detector.analyze_contract(request.clone()).await.unwrap();
        let duration2 = start_time2.elapsed();
        
        // Results should be identical
        assert_eq!(report1.contract_address, report2.contract_address);
        assert_eq!(report1.risk_score, report2.risk_score);
        assert_eq!(report1.vulnerabilities.len(), report2.vulnerabilities.len());
        
        // Second call should be significantly faster (cached)
        assert!(duration2 < duration1 / 2);
        
        // Check cache statistics
        let stats = detector.get_vulnerability_database_stats().await;
        assert!(stats.get("total_cached_reports").unwrap() > &0);
    }
    
    #[tokio::test]
    async fn test_bulk_analysis() {
        let config = DetectorConfig {
            max_concurrent_analyses: 3,
            ..DetectorConfig::default()
        };
        let detector = MockVulnerabilityDetector::new(config);
        
        // Create multiple analysis requests
        let requests = (1..=10).map(|i| ContractAnalysisRequest {
            contract_address: format!("0xbulkContract{:02x}", i),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: Some("bulk_analyzer".to_string()),
            position_ids: vec![i],
        }).collect();
        
        let start_time = std::time::Instant::now();
        let results = detector.bulk_analyze(requests).await;
        let duration = start_time.elapsed();
        
        assert_eq!(results.len(), 10);
        
        // All analyses should succeed
        for result in &results {
            assert!(result.is_ok());
        }
        
        // Should complete bulk analysis in reasonable time
        assert!(duration.as_secs() < 10);
        
        // Check metrics were updated
        let metrics = detector.get_metrics().await;
        assert_eq!(metrics.total_contracts_analyzed, 10);
    }
    
    #[tokio::test]
    async fn test_configuration_options() {
        // Test with bytecode analysis disabled
        let config1 = DetectorConfig {
            enable_bytecode_analysis: false,
            enable_transaction_monitoring: true,
            enable_audit_database_checks: true,
            ..DetectorConfig::default()
        };
        let detector1 = MockVulnerabilityDetector::new(config1);
        
        detector1.add_known_vulnerability("0xtest", Vulnerability {
            id: "TEST-001".to_string(),
            severity: VulnerabilitySeverity::High,
            category: VulnerabilityCategory::Reentrancy,
            description: "Test vulnerability".to_string(),
            impact: "Test impact".to_string(),
            confidence: 90,
            cvss_score: None,
            cwe_id: None,
            affected_functions: vec![],
            proof_of_concept: None,
            remediation: None,
        }).await;
        
        let request = ContractAnalysisRequest {
            contract_address: "0xtest".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: None,
            position_ids: vec![],
        };
        
        let report1 = detector1.analyze_contract(request.clone()).await.unwrap();
        
        // Should not find the vulnerability since bytecode analysis is disabled
        assert_eq!(report1.vulnerabilities.len(), 0);
        assert!(!report1.analysis_metadata.data_sources.contains(&"bytecode_analysis".to_string()));
        
        // Test with all analysis methods enabled
        let config2 = DetectorConfig::default();
        let detector2 = MockVulnerabilityDetector::new(config2);
        
        detector2.add_known_vulnerability("0xtest", Vulnerability {
            id: "TEST-001".to_string(),
            severity: VulnerabilitySeverity::High,
            category: VulnerabilityCategory::Reentrancy,
            description: "Test vulnerability".to_string(),
            impact: "Test impact".to_string(),
            confidence: 90,
            cvss_score: None,
            cwe_id: None,
            affected_functions: vec![],
            proof_of_concept: None,
            remediation: None,
        }).await;
        
        let report2 = detector2.analyze_contract(request).await.unwrap();
        
        // Should find the vulnerability with all methods enabled
        assert_eq!(report2.vulnerabilities.len(), 1);
        assert!(report2.analysis_metadata.data_sources.contains(&"bytecode_analysis".to_string()));
    }
    
    #[tokio::test]
    async fn test_risk_scoring_accuracy() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        // Test with critical vulnerability
        detector.add_known_vulnerability("0xhighrisk", Vulnerability {
            id: "HIGH-001".to_string(),
            severity: VulnerabilitySeverity::Critical,
            category: VulnerabilityCategory::Reentrancy,
            description: "Critical reentrancy".to_string(),
            impact: "Fund loss".to_string(),
            confidence: 100,
            cvss_score: Some(10.0),
            cwe_id: None,
            affected_functions: vec![],
            proof_of_concept: None,
            remediation: None,
        }).await;
        
        let high_risk_request = ContractAnalysisRequest {
            contract_address: "0xhighrisk".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Critical,
            requested_by: None,
            position_ids: vec![],
        };
        
        let high_risk_report = detector.analyze_contract(high_risk_request).await.unwrap();
        
        // Should have high risk score
        assert!(high_risk_report.risk_score >= 80);
        assert!(high_risk_report.confidence_score >= 90);
        
        // Test with low severity vulnerability
        detector.add_known_vulnerability("0xlowrisk", Vulnerability {
            id: "LOW-001".to_string(),
            severity: VulnerabilitySeverity::Low,
            category: VulnerabilityCategory::Information,
            description: "Informational issue".to_string(),
            impact: "Minor impact".to_string(),
            confidence: 60,
            cvss_score: Some(2.0),
            cwe_id: None,
            affected_functions: vec![],
            proof_of_concept: None,
            remediation: None,
        }).await;
        
        let low_risk_request = ContractAnalysisRequest {
            contract_address: "0xlowrisk".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::Low,
            requested_by: None,
            position_ids: vec![],
        };
        
        let low_risk_report = detector.analyze_contract(low_risk_request).await.unwrap();
        
        // Should have low risk score
        assert!(low_risk_report.risk_score <= 30);
        
        // High risk should be scored higher than low risk
        assert!(high_risk_report.risk_score > low_risk_report.risk_score);
    }
    
    #[tokio::test]
    async fn test_performance_benchmarking() {
        let config = DetectorConfig::default();
        let detector = MockVulnerabilityDetector::new(config);
        
        // Test analysis performance
        let request = ContractAnalysisRequest {
            contract_address: "0xperformanceTest".to_string(),
            chain_id: 1,
            priority: AnalysisPriority::High,
            requested_by: Some("performance_tester".to_string()),
            position_ids: vec![],
        };
        
        let start_time = std::time::Instant::now();
        let report = detector.analyze_contract(request).await.unwrap();
        let duration = start_time.elapsed();
        
        // Should complete analysis within performance target (<500ms)
        assert!(duration.as_millis() < 500, "Analysis took {}ms, should be <500ms", duration.as_millis());
        
        // Check that metadata includes timing information
        assert!(report.analysis_metadata.analysis_duration_ms > 0);
        assert!(report.analysis_metadata.analysis_duration_ms < 500);
        
        // Test concurrent analysis performance
        let concurrent_requests: Vec<_> = (1..=20).map(|i| ContractAnalysisRequest {
            contract_address: format!("0xConcurrent{:02x}", i),
            chain_id: 1,
            priority: AnalysisPriority::Normal,
            requested_by: Some("concurrent_tester".to_string()),
            position_ids: vec![i],
        }).collect();
        
        let concurrent_start = std::time::Instant::now();
        let concurrent_results = detector.bulk_analyze(concurrent_requests).await;
        let concurrent_duration = concurrent_start.elapsed();
        
        // All analyses should succeed
        assert_eq!(concurrent_results.len(), 20);
        for result in concurrent_results {
            assert!(result.is_ok());
        }
        
        // Concurrent analysis should be efficient
        assert!(concurrent_duration.as_secs() < 5, "Concurrent analysis took {}s, should be <5s", concurrent_duration.as_secs());
        
        // Check final metrics
        let final_metrics = detector.get_metrics().await;
        assert!(final_metrics.total_contracts_analyzed >= 21);
        assert!(final_metrics.average_analysis_time_ms > 0.0);
        assert!(final_metrics.average_analysis_time_ms < 500.0);
    }
}